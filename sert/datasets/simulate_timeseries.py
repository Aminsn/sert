import numpy as np
import pandas as pd


def ts_classification(num_series=1000, min_obs=10, max_obs=100, outlier_ratio=0.3, train_ratio=0.7,
                      outlier_value_range=(2, 3), time_range=(0, 100), value_range=(0, 1), random_seed=42):
    """
    Generates irregular time series data for classification. The data is generated by randomly sampling a number of time series with a random number of observations. Outliers are added to a fraction of the time series. The data is split into training and testing sets based on the id of the time series. The response variable is a binary variable indicating the presence of outliers for each time series.

    Parameters:
        num_series (int): Number of time series to generate.
        min_obs (int): Minimum number of observations for a time series.
        max_obs (int): Maximum number of observations for a time series.
        outlier_ratio (float): Fraction of series to which outliers should be added.
        train_ratio (float): Fraction of series to be used for training.
        outlier_value_range (tuple): Range for generating outlier values.
        time_range (tuple): Range for generating time points.
        value_range (tuple): Range for generating values of the observation.
        random_seed (int): Random seed for reproducibility.

    Returns:
        X_train (pd.DataFrame): Training dataset containing time series data.
        X_test (pd.DataFrame): Testing dataset containing time series data.
        y_train (pd.DataFrame): Training labels indicating presence (True) or absence (False) of outliers.
        y_test (pd.DataFrame): Testing labels indicating presence (True) or absence (False) of outliers.

    Example:
        X_train, X_test, y_train, y_test = ts_classification()

    Notes:
        The columns in the returned dataframes are:
        - id: Identifier for each time series.
        - time: Time point for each observation.
        - value: Value of the observation at the respective time.
        (For y_train and y_test) y: Binary label indicating if the time series has outliers (True) or not (False).
    """
    np.random.seed(random_seed)

    # Randomly sample numbers between min_obs and max_obs for number of observations per series
    n_obs = np.random.randint(min_obs, max_obs, num_series)

    # Randomly generate N samples within specified ranges for each number of observations in n_obs
    times = [np.random.uniform(time_range[0], time_range[1], n) for n in n_obs]
    values = [np.random.uniform(
        value_range[0], value_range[1], n) for n in n_obs]
    index = [np.repeat(i, n) for i, n in enumerate(n_obs)]

    # Create a pandas dataframe with the data
    df = pd.DataFrame(
        {
            "id": np.concatenate(index),
            "time": np.concatenate(times),
            "value": np.concatenate(values)
        }
    )

    # Sample a portion of the unique id's based on outlier_ratio
    unique_ids = df["id"].unique()
    sampled_ids = np.random.choice(unique_ids, int(
        len(unique_ids) * outlier_ratio), replace=False)

    # Create outliers for the sampled id's
    outliers_values = np.random.uniform(
        outlier_value_range[0], outlier_value_range[1], sampled_ids.shape[0])
    outliers_times = np.random.uniform(
        time_range[0], time_range[1], sampled_ids.shape[0])

    df_outliers = pd.DataFrame(
        {
            "id": sampled_ids,
            "time": outliers_times,
            "value": outliers_values
        }
    )

    # Merge original data with outliers and sort by id and time
    df = pd.concat([df, df_outliers]).sort_values(
        by=["id", "time"]).reset_index(drop=True)

    # Create a binary response variable indicating the presence of outliers for each unique id
    y = np.isin(np.sort(unique_ids), sampled_ids)
    df_y = pd.DataFrame({"id": np.sort(unique_ids), "y": y})

    # Add a variable name column to the data (required for SeqDataPreparer)
    df['var_name'] = 'var1'

    # Split data into training and testing sets based on the id
    split_idx = int(num_series * train_ratio)
    X_train = df.query(f'id < {split_idx}')
    X_test = df.query(f'id >= {split_idx}')
    y_train = df_y.query(f'id < {split_idx}')
    y_test = df_y.query(f'id >= {split_idx}')

    y_train = pd.get_dummies(y_train['y']).values*1
    y_test = pd.get_dummies(y_test['y']).values*1

    return X_train, X_test, y_train, y_test


def ts_forecasting(time_length, random_seed=42):
    """
    Simulates a multivariate time series based on a Gaussian process.

    Parameters:
    - time_length (int): The length of the time series to be generated.
    - random_seed (int, default=42): Seed to initialize the random number generator for reproducibility.

    Returns:
    - df (pd.DataFrame): A DataFrame containing the simulated multivariate time series.

    Example:
    df = ts_forecasting(1000)
    This will produce a DataFrame with 1000 rows and 4 columns (3 for the multivariate time series and 1 for the time).

    Note:
    This function requires the numpy library for random number generation and matrix operations and the pandas library to create the final DataFrame.
    """

    # --- Simulating data from a Guassian process --- #
    # Number of time series
    N = 3

    # Generate a vector from a Multivariate Guassian distribution
    # with mean mu and covariance matrix sigma
    np.random.seed(random_seed)

    # Generate mu_0
    mu_0 = np.random.uniform(0, 1, N)

    # Generate a symmetric matrix
    matrix = np.random.uniform(low=-1, high=1, size=(N, N))

    # Compute its Gram matrix to ensure positive-semidefiniteness
    cov_matrix = matrix @ matrix.T

    # Generate a random vector for the initial step
    mv_timeseries = mu_0.reshape((1, N))

    def get_signal(t):
        """
        Generates three signals for the given time step.

        Parameters:
        - t (int): The current time step.

        Returns:
        - x (numpy.ndarray): Signal evaluated for the given time step.
        """

        x = np.array([10*np.sin(.005*t),
                      -.002*t+10*np.sin(0.005*t),
                      5*np.sin(0.0005*t),
                      ])

        return x

    for t in range(1, time_length-1):
        mu_t = 2 + 0.4*mv_timeseries[t-1, :] + get_signal(t)
        mv_timeseries_new = np.random.multivariate_normal(
            mu_t, cov_matrix).reshape((1, N))
        mv_timeseries = np.vstack((mv_timeseries, mv_timeseries_new))

    # --- Create a dataframe with the generated time series --- #
    times = np.arange(1, time_length)

    # concatenate mv_timeseries and times
    mv_timeseries = np.concatenate(
        (times.reshape((time_length-1, 1)), mv_timeseries), axis=1)

    col_names = ['time'] + ['x' + str(i) for i in range(1, N+1)]
    df = pd.DataFrame(mv_timeseries, columns=col_names)

    return df
